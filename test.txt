from pathlib import Path
from cloudpathlib import S3Path

class ExtractMM:
    def __init__(self, main_path, calc_dt, mig_mtrx_file_nm, pd_vects_file_nm, rtgs_sorted_file_nm, output_path, mig_mtrx_nms, save=True):
        self.main_path = self._convert_to_path(main_path)
        self.calc_dt = calc_dt
        self.mig_mtrx_file_nm = self._convert_to_path(mig_mtrx_file_nm)
        self.pd_vects_file_nm = self._convert_to_path(pd_vects_file_nm)
        self.rtgs_sorted_file_nm = self._convert_to_path(rtgs_sorted_file_nm)
        self.output_path = self._convert_to_path(output_path)
        self.mig_mtrx_nms = mig_mtrx_nms
        self.save = save
        # Initialize other attributes as needed

    def _convert_to_path(self, path):
        if isinstance(path, str):
            if path.startswith('s3://'):
                return S3Path(path)
            else:
                return Path(path)
        return path

    def write(self):
        # Implement the write functionality
        pass



import unittest
import os
from pathlib import Path
from dotenv import load_dotenv
from IST.mig_mtrxs.extract_mig_mtrxs import ExtractMM

load_dotenv(dotenv_path="/home/jovyan/IST_plus_v0.01/config/.env")


class TestExtractMM(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.main_path = cls._get_env('BASE_PATH')
        cls.tests_path = Path(cls._get_env('TESTS_PATH'))
        cls.test_date = cls._get_env('TEST_DATE')

        test_file_path = Path(__file__).resolve()
        module = test_file_path.parents[1].name

        cls.data_path = cls.tests_path / module / 'data' / cls.test_date
        if not cls.data_path.exists():
            raise FileNotFoundError(f"Data path {cls.data_path} does not exist.")

        inputs_path = cls.data_path / "inputs"
        mig_mtrx_file_nm = inputs_path / f"{cls.test_date}_MIGRATION_MATRICES.csv"
        pd_vects_file_nm = inputs_path / f"{cls.test_date}_PD_VECTORS.csv"
        rtgs_sorted_file_nm = inputs_path / "ratings_sorted.xlsx"
        output_path = cls.data_path / "output"
        cls.targets_path = cls.data_path / "targets"

        cls.mig_mtrx_nms = ["CZ_CORP", "WW_GOV"]
        cls.mig_mtrxs_extract = ExtractMM(
            main_path=str(cls.main_path),
            calc_dt=cls.test_date,
            mig_mtrx_file_nm=str(mig_mtrx_file_nm),
            pd_vects_file_nm=str(pd_vects_file_nm),
            rtgs_sorted_file_nm=str(rtgs_sorted_file_nm),
            output_path=str(output_path),
            mig_mtrx_nms=cls.mig_mtrx_nms,
            save=True
        )
        cls.mig_mtrxs_extract.write()

    @staticmethod
    def _get_env(var_name):
        path_str = os.getenv(var_name, "")
        if not path_str:
            raise RuntimeError(f"The {var_name} environment variable has not been properly configured in the .env file")
        return path_str

    def test_mig_mtrxs(self):
        for mig_mtrx_nm, calc_mig_mtrx in self.mig_mtrxs_extract.mig_mtrxs.items():
            mig_mtrx_target_file_nm = self.targets_path / f"target-{mig_mtrx_nm}-mig_mtrx.csv"

            target_mig_mtrx = np.genfromtxt(mig_mtrx_target_file_nm, delimiter=",", dtype=float)
            self.assertTrue(np.allclose(calc_mig_mtrx, target_mig_mtrx, atol=1e-5), f"Mismatch found in migration matrix for {mig_mtrx_nm}")

    def test_pd_vects(self):
        for mig_mtrx_nm, calc_pd_vect in self.mig_mtrxs_extract.pd_vects.items():
            pd_vects_target_file_nm = self.targets_path / f"target-{mig_mtrx_nm}-pd_vector.csv"

            target_mig_mtrx = np.genfromtxt(pd_vects_target_file_nm, delimiter=",", dtype=float)
            self.assertTrue(np.allclose(calc_pd_vect, target_mig_mtrx, atol=1e-5), f"Mismatch found in pd vector for {mig_mtrx_nm}")

    def test_pd_ratings(self):
        for mig_mtrx_nm, calc_pd_grps in self.mig_mtrxs_extract.pd_grps.items():
            pd_grps_target_file_nm = self.targets_path / f"target-{mig_mtrx_nm}-pd_grps.csv"

            target_mig_mtrx = pd.read_csv(pd_grps_target_file_nm, header=None)
            try:
                assert_frame_equal(pd.DataFrame(calc_pd_grps), target_mig_mtrx, check_names=False)
            except AssertionError as e:
                self.fail(f"Mismatch found in pd groups for {mig_mtrx_nm}")


if __name__ == '__main__':
    unittest.main()
